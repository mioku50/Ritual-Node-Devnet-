# Medium



Ritual разрабатывает сопроцессор искусственного интеллекта для блокчейна, цель которого — плавная интеграция моделей искусственного интеллекта в протоколы, приложения или смарт-контракты с минимальным кодированием. Он служит открытым, суверенным слоем исполнения, который позволяет приложениям внедрять ИИ в любой блокчейн. Ritual способствует демократизации ИИ, обеспечивая тонкую настройку, монетизацию и вывод моделей с помощью криптографических схем, что способствует созданию экосистемы для децентрализованного ИИ. Платформа делает упор на конфиденциальность, защиту от цензуры и верифицируемость, обеспечивая широкий и безопасный доступ к моделям ИИ по всему миру. Для разработчиков Ritual, упрощает процесс интеграции с помощью простого в использовании SDK, поощряя использование мощностей GPU для поддержки сети.

_**Ritual Superchain: понимание архитектуры Ritual**_

Ritual Superchain, служащая базовой инфраструктурой Ritual, состоит из нескольких слоев и компонентов:

_Модульные прекомпы (Stateful Precompiles, SPCs)_: SPCs — это специализированные смарт-контракты, которые могут получать доступ к состоянию и эффективно обрабатывать сложные функции ИИ, начиная от дистилляции знаний и заканчивая тонкой настройкой и выводами. Эти SPC разработаны для беспрепятственной интеграции в другие типы виртуальных машин (ВМ), предлагаемых сообществом.

_Уровень общей передачи сообщений (General Message Passing, GMP)_: Обеспечивает взаимодействие между существующими блокчейнами и Ritual Superchain, позволяя Ritual выступать в качестве сопроцессора ИИ для всех блокчейнов.

_AI VM_: содержит SPC и инфраструктуру базового уровня для оптимизированного выполнения моделей ИИ.

_Набор узлов_: Состоит из различных классов узлов с разными функциональными возможностями и требованиями к ресурсам, включая полные узлы, узлы валидатора, узлы доказательства, узлы кэширования моделей и узлы конфиденциальности.

_Модели и хранилище моделей_: В Ritual модели — это специальные инструменты ИИ для решения различных задач. Думайте об этих моделях как о приложениях на вашем телефоне, которые вы можете использовать, когда они вам нужны. Они могут храниться на телефоне (узел) или загружаться из специального места, где их могут получить все желающие (реестр моделей). Модели Ritual используются SPC и хранятся в защищенном от цензуры слое хранения без разрешений.

Порталы: Позволяют оценить модели на исходных цепочках перед взаимодействием с Ritual Superchain.

_Хранители_: С помощью Guardians, узлы выступают в роли привратников, следящих за тем, чтобы интегрировались и использовались только релевантные и приемлемые модели.

_Общий секвенсор_: Позволяет всем слоям в Ritual работать слаженно и организованно.

_Уровень доступности данных (DA)_: В Ritual пользователи получают контроль над тем, как хранится их информация и как к ней можно получить доступ.

_Постоянное хранение_: Требуется для доказательства, обеспечения конфиденциальности и полной детерминированной реконструкции вычислений.

_Маршрутизаторы_: Направляют задачи Web2 AI на узлы Ritual, основываясь на предпочтениях пользователей в отношении качества обслуживания, конфиденциальности, вычислительной целостности и стоимости. Пользователи могут настраивать параметры или полагаться на автоматически выбранные конфигурации.

_Первоначальная безопасность с помощью Eigenlayer_: Ritual будет подключаться к системе безопасности первого уровня Ethereum через Eigenlayer, который действует как мост. По мере развития экосистемы Ritual стремится к разработке собственных мер безопасности.

Ritual получил финансирование в размере 25 миллионов долларов\
в ноябре 2023 года. Этот раунд финансирования получил поддержку от известных инвесторов и ангелов, включая Accomplice и Robot Ventures, что подтверждает доверие инвесторов к Ritual и способствует выходу компании на новый этап развития и инноваций.

**Установка Узла**

_Минимальные и рекомендуемые характеристики оборудования, необходимые для данного узла:_

_**1- Обновляем пакеты:**_

```
sudo apt update && sudo apt upgrade -y
```

_**2- Установка дополнительных инструментов:**_

```
sudo apt -qy install curl git jq lz4 build-essential screen
```

```
sudo apt install docker.io
docker --versionsudo curl -L "https://github.com/docker/compose/releases/download/v2.24.5/docker-compose-$(uname -s)-$(uname -m)" -o /usr/local/bin/docker-compose
sudo chmod +x /usr/local/bin/docker-compose
docker-compose --version
```

_**3- Клонируем репозиторий Ritual:**_

```
git clone https://github.com/ritual-net/infernet-container-startercd infernet-container-starter
```

**4. **_**Далее вводим:**_

```
screen -S ritualproject=hello-world make deploy-container
```

Выходим из сеанса, нажимая CTRL+A+D

Проверяем, запустились ли контейнеры, должно быть так:

```
docker container ls
```

**Меняем Config.json:**

_**Открываем второе окно и вводим:**_

```
nano ~/infernet-container-starter/deploy/config.json
```

Далее обновляем наш конфиг, вписывая следующие данные:

_Адрес координатора:_ Изменяем его на 0x8D871Ef2826ac9001fB2e33fDD6379b6aaBF449c\
_RPC URL:_ Обновляем это значение RPC URL — [https://base-rpc.publicnode.com/](https://base-rpc.publicnode.com/).\
_Private Key:_ Замените поле private\_key на приватный ключ вашего кошелька ETH (Metamask) . Убедитесь, что на вашем кошельке есть около $5 ETH в Base Network , чтобы покрыть расходы на транзакции. Также убедитесь, что ваш приватный ключ начинается с “0x”. Если это не так, добавьте “0x” в начало вашего приватного ключа, чтобы убедиться, что он правильно распознан.

_**Меняем MakeFile:**_

```
nano ~/infernet-container-starter/projects/hello-world/contracts/Makefile
```

* `sender`'s address ваш приватный ключ
* `RPC_URL` — [`https://base-rpc.publicnode.com`](https://base-rpc.publicnode.com/)

_**Меняем Deploy.s.sol:**_

```
nano ~/infernet-container-starter/projects/hello-world/contracts/script/Deploy.s.sol
```

* измените `coordinator_address 0x8D871Ef2826ac9001fB2e33fDD6379b6aaBF449c`

_**Перезапускаем контейнеры:**_

```
docker restart anvil-node
docker restart hello-world
docker restart deploy-node-1
docker restart deploy-fluentbit-1
docker restart deploy-redis-1
```

**Деплой контракта:**

_Установка Foundry а также зависимостей_

```
cd
mkdir foundry
cd foundry
curl -L https://foundry.paradigm.xyz | bash
source ~/.bashrc
foundryup
```

```
cd ~/infernet-container-starter/projects/hello-world/contracts
forge install --no-commit foundry-rs/forge-std
forge install --no-commit ritual-net/infernet-sdk
cd ../../../
```

```
cd ~/infernet-container-starter
make deploy-contracts project=hello-world
```

_**После ввода команд вы должны увидеть примерно следующее:**_

Сохраняем адрес контракта — пример `0x663f3ad617193148711d28f5334ee4ed07016602`

Далее перейдем в CallContact.sol и изменим адрес в строке _SayGm Address_ на тот который мы получили выше.

```
nano ~/infernet-container-starter/projects/hello-world/contracts/script/CallContract.s.sol
```

Теперь вызовем контракт, инициирущий запрос к узлу:

```
project=hello-world make call-contract
```

_**Результат должен быть примерно таким:**_

Все, этот шаг завершен.

**Ну и последний шаг, зарегистрируем свой узел в сети.**

Переходим сюда — [https://basescan.org/address/0x8d871ef2826ac9001fb2e33fdd6379b6aabf449c#writeContract](https://basescan.org/address/0x8d871ef2826ac9001fb2e33fdd6379b6aabf449c#writeContract)

Cпускаеся ниже и видим пункт “Node Address” кликаем на него и вводим свой публичный адрес EVM кошелька (Metamask)

Адрес должен быть тот же от которого мы использовали приватный ключ в шагах выше.

Нажимаем “Write” и ждем около часа

Подождав около часа, нажимаем на пункт “Activate Node” и нажимаем “Write” после этого наш узел успешно будет зарегистрирован!

**Официальные ссылки:**

_Сайт —_ [_https://ritual.net/_](https://ritual.net/)

_Twitter —_ [_https://twitter.com/ritualnet_](https://twitter.com/ritualnet)

_Discord —_ [_https://discord.gg/h2ZAwunb_](https://discord.gg/h2ZAwunb)
